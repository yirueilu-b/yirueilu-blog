{"componentChunkName":"component---src-templates-post-js","path":"/blog/ebb67b","result":{"pageContext":{"md_path":"leetcode485","title":"LeetCode 485. Max Consecutive Ones","description":"Given a binary array, find the maximum number of consecutive 1s in this array.Example 1:\nInput: [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two dig...","image":"https://dkmonster.github.io/assets/images/leetcode/LeetCode_Sharing.png","uuid":"ebb67b","text":"# LeetCode 485. Max Consecutive Ones\n\n![](https://dkmonster.github.io/assets/images/leetcode/LeetCode_Sharing.png)\n\n## Description\n\nGiven a binary array, find the maximum number of consecutive 1s in this array.\n\n**Example 1:**\n```\nInput: [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s.\n    The maximum number of consecutive 1s is 3.\n```\n\n**Note:**\n- The input array will only contain 0 and 1.\n- The length of input array is a positive integer and will not exceed 10,000\n\n## Idea\n\nTrivial, just use a for loop to iterate through the `nums` array.\n\nFirst we keep two variables `ans` and `temp_ones`, `ans` is for recording max consecutive ones and `temp_ones` is for recording current consecutive ones.\n\nIn the for loop, if the value is equal to 1 then we add `temp_ones` by 1 else clear `temp_ones` as 0\n\nand in the end of every iteration, we update `ans` by comparing `temp_ones` and `ans` thus keep `ans` as maximum consecutive ones.\n\n\n## Solution\n\n```python\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        ans = 0\n        temp_ones = 0\n        for n in nums:\n            if n == 1:\n                temp_ones += 1\n            else:\n                temp_ones = 0\n            ans = max(temp_ones, ans)\n        return ans\n```\n> **Complexity**\n> - Time complexity: `O(n)`\n>   Iterate through `n` given `nums`\n> - Space complexity: `O(1)`\n>   Only constant variables for keeping number of consecutive ones and max number of consecutive ones\n\n## Note\n\n- Visualize the process:\n\n```python\ndef plot_nums(nums, index1, index2, ans):\n    length = len(nums)\n    height = 1\n    plt.figure(figsize=(length,4))\n    plt.xlim([-1, length+1])\n    plt.ylim([-1.5, 2.5])\n    # plot arr\n    rect = patches.Rectangle((0, 0), length, height, lw=1, fill=0, ec='steelblue')\n    plt.gca().add_patch(rect)\n    for i in range(length):\n        plt.plot([i, i], [height, 0], c='steelblue', lw=1)\n        plt.text(i + 0.5 - 0.08*len(str(i)), 1 + 0.08, i, fontsize=10, color='steelblue')\n        plt.text(i + 0.5 - 0.09, 0.5 - 0.09, nums[i], fontsize=14, color='r')\n    # plot current ones\n    rect = patches.Rectangle((index1+1, 0), -index2, height, lw=1, fc=(0.19607843, 0.80392157, 0.19607843, 0.2))\n    plt.gca().add_patch(rect)\n    # arrow for index\n    if index1 >= 0:\n        plt.arrow(index1 + 0.5, 1.8, 0, -0.25, head_width=0.1, color='k')\n\n    if index1 == -1:\n        index1 = 'init'\n    plt.title('i = {}\\ncurrent number of ones = {}\\nans = {}'.format(index1, index2, ans))\n\n    plt.axis('off')\n    plt.tight_layout()\n    # plt.savefig('{}.jpg'.format(index1))\n    plt.show()\n\nnums = [1,1,0,1,1,0,1,1,1]\nans = 0\ntemp_ones = 0\nplot_nums(nums, -1, temp_ones, ans)\nfor i, n in enumerate(nums):\n    if n == 1:\n        temp_ones += 1\n    else:\n        temp_ones = 0\n    ans = max(temp_ones, ans)\n    plot_nums(nums, i, temp_ones, ans)\n```\n\n![](https://github.com/yirueilu-b/coding-problems-and-notes/raw/master/leetcode/arrays101/max_consecutive_ones.gif)\n\n###### tags: `Coding`"}},"staticQueryHashes":[]}